import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image_picker/image_picker.dart';
import 'package:magh/features/books/domain/book.dart';
import 'package:magh/features/cloudinary/data/cloudinary_repository.dart';
import 'package:magh/features/shared/instances.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'book_repository.g.dart';


class BookRepository {

  Stream<List<Book>> getBooks(){
    return
      FirebaseInstances.bookDb.snapshots().map((event) => event.docs.map((e) {
        final map = e.data();
        return Book.fromJson({...map, 'id': e.id});
      }).toList());
  }


  Future<void> addBook ({
    required File file,
    required XFile image,
    required String title,
    required String genre,
    required int price,
    required String publisher,
    required String author,
    required String description
  }) async{
    try{
      final response1 = await CloudinaryRepository.uploadImage(file);
      final response2 = await CloudinaryRepository.uploadImage(F(image.path));

         await FirebaseInstances.bookDb.add({
           'title': title,
           'genre': genre,
           'price': price,
           'publisher': publisher,
           'author': author,
           'image': response2.secureUrl,
           'file': response1.secureUrl,
           'description': description
         });

    } on FirebaseException catch(err){
      throw '${err.message}';

    }catch(err){
      throw '$err';
    }


  }



  Future<void> updateBook ({
     File? file,
     XFile? image,
     String? imageUrl,
     String? fileUrl,
    required String title,
    required String genre,
    required int price,
    required String publisher,
    required String author,
    required String description,
    required String bookId,
  }) async{
    // try{
    //
    //   CloudinaryResponse? response1;
    //   CloudinaryResponse? response2;
    //   if(image != null){
    //     print('hello');
    //     await CloudinaryInstances.delCloudinary.destroy(
    //       'public_id',
    //       url: imageUrl,
    //       invalidate: true,
    //     );
    //       response1 = await CloudinaryInstances.cloudinary.uploadFile(
    //        CloudinaryFile.fromFile(image.path, resourceType: CloudinaryResourceType.Image),
    //      );
    //   }
    //   if(file != null){
    //     await CloudinaryInstances.delCloudinary.destroy(
    //       'public_id',
    //       url: fileUrl,
    //      resourceType: cloud.CloudinaryResourceType.image,
    //       invalidate: false,
    //     );
    //      response2 = await CloudinaryInstances.cloudinary.uploadFile(
    //       CloudinaryFile.fromFile(file.path),
    //     );
    //   }
    //
    //
    //   await FirebaseInstances.bookDb.doc(bookId).update({
    //     'title': title,
    //     'genre': genre,
    //     'price': price,
    //     'publisher': publisher,
    //     'author': author,
    //     'image': response1?.secureUrl ?? imageUrl,
    //     'file': response2?.secureUrl ?? fileUrl,
    //     'description': description
    //   });
    //
    // } on FirebaseException catch(err){
    //   throw '${err.message}';
    //
    // }on CloudinaryException catch(err){
    //   print(err);
    //   throw '${err.message}';
    // }catch(err){
    //   print(err);
    // }


  }



}

@riverpod
BookRepository bookRepo(Ref ref) {
  return BookRepository();
}